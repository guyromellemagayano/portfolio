---
description: Component Architecture Standards
globs: ["apps/**/*.tsx", "packages/**/*.tsx"]
alwaysApply: false
---

<!-- markdownlint-disable -->

# Component Architecture Standards

## Component Classification

### Component Types

1. **Compound Components**: Main component with orchestrated sub-components
   - Structure: `_internal/` folder with sub-components
   - Tests: Both unit AND integration tests
   - Example: Card, Tabs, Accordion

2. **Orchestrator Components**: Coordinates multiple independent components
   - Structure: Flat, imports other components
   - Tests: Unit tests only (integration happens at parent level)
   - Example: ArticleLayout, DashboardView

3. **Presentational Components**: Pure display, no sub-components
   - Structure: Single file + tests + `constants/Component.i18n.ts`
   - Tests: Unit tests only
   - Example: Article, Button, Badge

4. **Utility Components**: Wrappers around primitives
   - Structure: Single file
   - Tests: Basic unit tests (60% coverage acceptable)
   - Example: Container, Section, Grid

## Required Component Classification Comments

All component files must include:

```typescript
// ============================================================================
// COMPONENT CLASSIFICATION
// - Type: Compound/Orchestrator/Presentational/Utility
// - Testing: Unit + Integration tests (both required) / Unit tests only / Basic unit tests
// - Structure: _internal/ folder with sub-components / Flat, imports other components / Single file + tests + constants/Component.i18n.ts / Single file
// - Risk Tier: Tier 1 (90%+ coverage, comprehensive edge cases) / Tier 2 (80%+ coverage, key paths + edges) / Tier 3 (60%+ coverage, happy path + basic validation)
// - Data Source: Static data (no external data fetching) / Sanity CMS (GROQ queries) / External API / GraphQL
// ============================================================================
```

## Scalable Folder Structure

### For Compound Components (with sub-components)

```bash
components/Component/
├── Component.tsx              # Main component
├── index.ts                   # Public exports
├── __tests__/
│   ├── Component.test.tsx
│   └── Component.integration.test.tsx
├── _types/                    # Shared types (main + internal)
│   ├── index.ts
│   └── Component.types.ts
├── _internal/                 # Sub-components
│   ├── index.ts
│   ├── SubComponent/
│   │   ├── SubComponent.tsx
│   │   ├── SubComponent.module.css
│   │   └── __tests__/
│   └── _types/               # Internal-only types
│       ├── index.ts
│       └── Internal.types.ts
├── _data/                    # Constants, labels, defaults
│   ├── index.ts
│   ├── Component.data.ts
│   └── Component.i18n.ts
└── _queries/                 # GraphQL/API (if needed)
    ├── index.ts
    ├── Component.queries.ts
    └── Component.mutations.ts
```

### For Orchestrator/Presentational Components (no sub-components)

```bash
components/Component/
├── Component.tsx              # Main component
├── Component.module.css
├── index.ts
├── __tests__/
│   └── Component.test.tsx    # Unit tests only
├── constants/
│   └── Component.i18n.ts     # Internationalization labels
└── _data/                    # Optional: if shared data/types
    ├── index.ts
    ├── Component.data.ts
    └── Component.types.ts
```

## Type Organization Rules

- **Inline types**: Component-specific interfaces in component file (default)
- **`_types/`**: Only when types shared between main + internal sub-components
- **`_data/Component.types.ts`**: Only when types shared across multiple components
- **Never**: Separate `.types.ts` for single-component types

## Data Organization Rules

- **`_data/Component.data.ts`**: Constants, defaults, configuration
- **`_data/Component.i18n.ts`**: Internationalization labels (use dot notation: `Component.i18n.ts`)
- **`_data/Component.types.ts`**: Types shared across multiple components
- **`_queries/`**: GraphQL queries/mutations (separate from data)
- **Never**: Business logic, API calls, or complex transformations in `_data/`

## Internal Component Standards

- **`_internal/` Purpose**: Sub-components used only within their parent component
- **No Public Exports**: Never export internal components from main `index.ts`
- **Internal-Only Access**: Only import from `_internal/` within the same component tree
- **Compound Pattern**: External consumers use `Component.SubComponent` pattern
- **Encapsulation**: Prevents external components from importing internal sub-components directly
- **Type Safety**: Internal components can use private types from `_types/` folder
- **ESLint Enforcement**: Custom ESLint rule automatically blocks cross-component imports from `internal/`, `data/`, `types/`, `constants/`, `queries/` folders and any folder starting with `_`

## Component Props Standards

- **Main Components**: Use `setDisplayName` for proper component naming, extend `React.ComponentProps<typeof ElementType>` + `CommonComponentProps` for utility props
- **Sub-components**: Use `useComponentId` hook internally, receive `internalId`/`debugMode` props directly, use `setDisplayName`, `hasAnyRenderableContent` for content validation
- **Component Props**: Extend `React.ComponentProps<typeof BaseComponent>` + `CommonComponentProps` for utility props
- **Consistent Prop Names**: All components use `internalId`/`debugMode` (external props) from `CommonComponentProps`
- **Compound Components**: Manually attach sub-components as properties to main component

## Type Organization Standards

- **`_types/` Purpose**: Main component types shared between main and internal components
- **`_internal/_types/` Purpose**: Private internal types shared only between sub-components
- **Main Types**: Component interfaces used by main component and accessible to internal components
- **Internal Types**: Component-specific interfaces used only within the component's internal structure
- **Encapsulation**: Prevents external components from importing internal type definitions
- **Loose Coupling**: External components should use `React.ComponentProps<typeof Component>` instead
- **Main Usage**: Types used by main component and shared with internal sub-components
- **Internal Usage**: Types used by sub-components within the same component family only
- **Export Pattern**: Re-export from both `_types/index.ts` and `_internal/_types/index.ts` for clean imports

## Type Documentation Standards

- **Exported Types**: Always document exported types with JSDoc comments
- **Type Properties**: Document all type properties with `/** */` comments
- **Union Types**: Document each union variant with descriptive comments
- **Interface Properties**: Document each interface property with purpose and constraints
- **Type Aliases**: Document type aliases with their intended usage
- **Generic Types**: Document generic type parameters and constraints
- **One-liner Comments**: Use single-line `/** */` format instead of multiline for concise documentation
- **JSDoc Titles**: Use uppercase for JSDoc comment titles only when they serve as section headers (e.g., `/** FOOTER LINK CONFIGURATION */`), otherwise use proper English casing (e.g., `/** Internal link */`)

## Internationalization (i18n) Standards

### File Naming Conventions

- **Use dot notation**: `Component.i18n.ts` (not `ComponentLabels.ts` or `ComponentLabels.i18n.ts`)
- **Consistent naming**: All i18n files follow the pattern `{ComponentName}.i18n.ts`
- **Clear intent**: The `.i18n.ts` extension immediately indicates internationalization purpose
- **Future-ready**: Perfect for Sanity CMS + third-party i18n package integration

### i18n File Structure

```typescript
// ============================================================================
// COMPONENT INTERNATIONALIZATION
// ============================================================================

/** `ComponentI18n` type. */
export type ComponentI18n = Readonly<Record<string, string>>;

/** `COMPONENT_I18N` object. */
export const COMPONENT_I18N = {
  // Action labels
  cta: "Call to action",
  submit: "Submit",
  cancel: "Cancel",

  // Content labels
  title: "Title",
  description: "Description",

  // Navigation labels
  goBack: "Go back",
  nextPage: "Next page",

  // Error messages
  invalidData: "Invalid data provided",
  requiredField: "This field is required",

  // Accessibility labels
  ariaLabel: "Accessible label",
  ariaDescription: "Accessible description",
} as const satisfies ComponentI18n;
```

### i18n Integration Patterns

- **Import pattern**: `import { COMPONENT_I18N } from "./constants/Component.i18n";`
- **Usage pattern**: `{COMPONENT_I18N.cta}` or `aria-label={COMPONENT_I18N.ariaLabel}`
- **Type safety**: Use `satisfies ComponentI18n` for compile-time validation
- **Const assertion**: Use `as const` for literal type inference
- **Readonly**: Use `Readonly<Record<string, string>>` for immutability

## Testing Standards

### Rantail CSS Obfuscation Testing Rules

**CRITICAL**: When using Rantail for Tailwind CSS obfuscation, tests must NOT expect specific classnames as they are transformed during build.

#### ❌ Forbidden Patterns

```typescript
// ❌ NEVER test specific classnames with Rantail
expect(element).toHaveClass("mt-16", "lg:mt-32");
expect(element).toHaveClass("text-4xl", "font-bold", "tracking-tight");
expect(element).toHaveClass("md:border-l", "md:border-zinc-100");
```

#### ✅ Required Patterns

```typescript
// ✅ Test that class attribute exists (generic)
expect(element).toHaveAttribute("class");

// ✅ Test specific functionality, not styling
expect(element).toHaveAttribute("data-testid", "component-root");
expect(element).toHaveAttribute("aria-label", "Component description");
expect(element).toHaveAttribute("role", "button");

// ✅ Test component behavior, not CSS classes
expect(element).toBeInTheDocument();
expect(element).toHaveTextContent("Expected text");
expect(element).toHaveAttribute("href", "/expected-path");
```

#### Implementation Guidelines

1. **Replace all classname expectations** with `toHaveAttribute("class")`
2. **Focus on functionality** rather than styling in tests
3. **Test data attributes** for component identification
4. **Test ARIA attributes** for accessibility
5. **Test component behavior** and user interactions

#### Example Transformation

```typescript
// Before (❌ Brittle with Rantail)
it("applies correct CSS classes", () => {
  render(<Component className="custom-class" />);
  const element = screen.getByTestId("component-root");
  expect(element).toHaveClass("mt-16", "lg:mt-32", "custom-class");
});

// After (✅ Rantail-compatible)
it("applies custom className", () => {
  render(<Component className="custom-class" />);
  const element = screen.getByTestId("component-root");
  expect(element).toHaveAttribute("class");
});
```

### Test Coverage Requirements

- **Critical Components** (auth, payments, data mutations): 90%+ coverage, comprehensive edge cases
- **Core Components** (layout, navigation, forms): 80%+ coverage, key paths + edges
- **Presentational Components**: 60%+ coverage, happy path + basic validation
- **Utility Functions**: 100% coverage for shared utils, 80% for component-specific

### Test Organization

```bash
components/Component/
├── __tests__/
│   ├── Component.test.tsx           # Unit tests (always required)
│   ├── Component.integration.test.tsx  # Only if compound component
│   └── Component.e2e.test.tsx       # Only for critical user flows
```

### Required Test Categories

#### 1. Basic Rendering Tests

- ✅ Renders children correctly
- ✅ Applies custom className (generic check only)
- ✅ Renders with debug mode enabled
- ✅ Renders with custom component ID
- ✅ Passes through HTML attributes

#### 2. Content Validation Tests

- ✅ Does not render when no content
- ✅ Handles null/undefined/empty children
- ✅ Validates content with `hasAnyRenderableContent`

#### 3. Debug Mode Tests

- ✅ Applies data-debug-mode when enabled
- ✅ Does not apply when disabled/undefined

#### 4. Component Structure Tests

- ✅ Renders as correct element type
- ✅ Applies correct CSS classes (generic check only)
- ✅ Combines CSS module + custom classes (generic check only)

#### 5. Ref Forwarding Tests

- ✅ Forwards ref correctly
- ✅ Ref points to correct element

#### 6. Accessibility Tests

- ✅ Proper semantic structure
- ✅ Correct data attributes for debugging

### Mocking Standards

#### Required Mocks for All Components

```typescript
// Mock useComponentId hook
const mockUseComponentId = vi.hoisted(() =>
  vi.fn((options = {}) => ({
    id: options.internalId || "test-id",
    isDebugMode: options.debugMode || false,
  }))
);

vi.mock("@guyromellemagayano/hooks", () => ({
  useComponentId: mockUseComponentId,
}));

// Mock utility functions
vi.mock("@guyromellemagayano/utils", () => ({
  hasAnyRenderableContent: vi.fn((children) => {
    if (children === false || children === null || children === undefined) {
      return false;
    }
    if (typeof children === "string" && children.length === 0) {
      return false;
    }
    return true;
  }),
  hasMeaningfulText: vi.fn((content) => content != null && content !== ""),
  setDisplayName: vi.fn((component, displayName) => {
    if (component) component.displayName = displayName;
    return component;
  }),
  createComponentProps: vi.fn(
    (id, componentType, debugMode, additionalProps = {}) => ({
      [`data-${componentType}-id`]: `${id}-${componentType}`,
      "data-debug-mode": debugMode ? "true" : undefined,
      "data-testid":
        additionalProps["data-testid"] || `${id}-${componentType}-root`,
      ...additionalProps,
    })
  ),
}));

// Mock CSS modules
vi.mock("../ComponentName.module.css", () => ({
  default: { componentName: "componentName" },
}));
```

### Test Query Standards

#### Preferred Query Methods (in order)

1. **`getByRole`** - Most accessible, user-focused
2. **`getByLabelText`** - For form elements
3. **`getByPlaceholderText`** - For inputs
4. **`getByText`** - For text content
5. **`getByDisplayValue`** - For form values
6. **`getByTestId`** - Last resort, use with `data-testid`

#### Avoid These Queries

- ❌ `getByClassName` - Brittle, implementation detail
- ❌ `getById` - Not user-focused
- ❌ `querySelector` - Too generic, bypasses RTL benefits

### Test Data Attributes

#### Standard Test IDs

```typescript
// Component root elements
data-testid="${id}-${componentType}-root"

// Examples:
data-testid="test-id-card-root"
data-testid="test-id-header-root"
data-testid="test-id-footer-root"
```

#### Debug Attributes

```typescript
// Debug mode
data-debug-mode="true" // when enabled
// No attribute when disabled

// Component IDs
data-${componentType}-id="${id}-${componentType}"
// Examples:
data-card-id="test-id-card"
data-header-id="test-id-header"
```

## Utility Function Standards

- **`useComponentId`**: For ID generation and debug mode in sub-components
- **`setDisplayName`**: For component naming in all components
- **`hasAnyRenderableContent`**: For content validation in main components
- **`hasMeaningfulText`**: For content validation in sub-components
- **`isValidLink`**: For link validation
- **`getLinkTargetProps`**: For link target/rel attributes
- **`createComponentProps`**: For component data attributes
- **`cn`**: For className composition from `@web/utils`

## ESLint Component Encapsulation Rule

### Automatic Enforcement

A custom ESLint rule (`component-encapsulation/no-underscore-folder-imports`) automatically enforces component encapsulation across the entire monorepo.

### Blocked Patterns

The rule prevents cross-component imports from private folders:

```typescript
// ❌ BLOCKED - Importing from another component's private folders
import { SimpleLayout } from "@web/components/Layout/internal";
import { FOOTER_I18N } from "@web/components/Footer/constants";
import { type FooterLink } from "@web/components/Footer/data";
import { ARTICLE_QUERY } from "@web/components/Article/queries";
import { type CardProps } from "@web/components/Card/types";
import { InternalComponent } from "@web/components/Header/_internal";
```

### Allowed Patterns

```typescript
// ✅ ALLOWED - Relative imports within the same component
import { SimpleLayout } from "./internal";
import { FOOTER_I18N } from "./constants";
import { type FooterLink } from "./data";

// ✅ ALLOWED - Barrel exports from other components
import { Layout, Footer, Card } from "@web/components";
```

### Protected Folders

The rule automatically blocks imports from:

- `internal/` - Internal sub-components
- `data/` - Component data and constants
- `types/` - Component-specific types
- `constants/` - Internationalization and labels
- `queries/` - GraphQL/API queries
- Any folder starting with `_` (e.g., `_internal/`, `_data/`, `_types/`)

### Error Message

When a violation is detected:

```
Cross-component import from private folder detected.

Import: @web/components/Layout/internal
From:   apps/web/src/components/Header/Header.tsx

Private folders (starting with _) are not meant to be imported across components.

Fix options:
  1. Use the component's barrel export: import { Component } from '@web/components'
  2. If within the same component, use relative imports: import { X } from './_internal'
```

### Implementation

The rule is defined inline in `packages/config-eslint/src/index.js` and uses regex pattern matching to detect cross-component imports. It works with both underscore-prefixed folders (`_internal`) and non-prefixed folders (`internal`) for maximum compatibility.

**Regex Pattern:** `/@(apps)\/components\/[^/]+\/(_[^/]+|internal|data|types|constants|queries)/`

**Pattern Breakdown:**

- `@(apps)` - matches `@apps` workspace
- `\/components\/` - matches the components folder
- `[^/]+` - matches component name (e.g., "Layout", "Footer", "Header")
- `\/(_[^/]+|internal|data|types|constants|queries)` - matches any private folder (with or without underscore prefix)

## Test Suite Standardization Process

### Comprehensive Test Fixing Workflow

When fixing test suites across components, follow this systematic approach to ensure consistency and reliability:

#### 1. Mock Standardization

**Critical Mock Fixes Required:**

```typescript
// ✅ CORRECT: useComponentId mock with proper return structure
const mockUseComponentId = vi.hoisted(() =>
  vi.fn((options = {}) => ({
    componentId: options.internalId || options.debugId || "test-id", // Support both prop names
    isDebugMode: options.debugMode || false,
  }))
);

// ✅ CORRECT: createComponentProps mock with proper data-testid generation
createComponentProps: vi.fn(
  (id, componentType, debugMode, additionalProps = {}) => ({
    [`data-${componentType}-id`]: `${id}-${componentType}`,
    "data-debug-mode": debugMode ? "true" : undefined,
    "data-testid": additionalProps["data-testid"] || `${id}-${componentType}`, // No -root suffix
    ...additionalProps,
  })
),
```

**Common Mock Issues Fixed:**

- **`useComponentId` return structure**: Changed from `{ id, isDebugMode }` to `{ componentId, isDebugMode }`
- **Prop name compatibility**: Support both `internalId` and `debugId` for backward compatibility
- **`data-testid` generation**: Remove `-root` suffix to match actual implementation
- **Consistent fallback values**: Use `"test-id"` as default component ID

#### 2. Rantail CSS Obfuscation Compliance

**Remove All Classname Expectations:**

```typescript
// ❌ FORBIDDEN: Specific classname expectations
expect(element).toHaveClass("mt-16", "lg:mt-32");
expect(element).toHaveClass("text-4xl", "font-bold");

// ✅ REQUIRED: Generic class attribute checks
expect(element).toHaveAttribute("class");
```

**Implementation Pattern:**

```typescript
// Before (❌ Brittle with Rantail)
it("applies correct CSS classes", () => {
  render(<Component className="custom-class" />);
  const element = screen.getByTestId("component-root");
  expect(element).toHaveClass("mt-16", "lg:mt-32", "custom-class");
});

// After (✅ Rantail-compatible)
it("applies custom className", () => {
  render(<Component className="custom-class" />);
  const element = screen.getByTestId("component-root");
  expect(element).toHaveAttribute("class");
});
```

#### 3. Data Attribute Standardization

**Standard Test ID Pattern:**

```typescript
// ✅ CORRECT: data-testid format
data-testid="${componentId}-${componentType}"

// Examples:
data-testid="test-id-article-list"
data-testid="test-id-link-root"
data-testid="test-id-layout-main"
```

**Debug Attribute Pattern:**

```typescript
// ✅ CORRECT: Debug mode attributes
data-debug-mode="true" // when enabled
// No attribute when disabled

// ✅ CORRECT: Component ID attributes
data-${componentType}-id="${componentId}-${componentType}"
```

#### 4. Test Query Standardization

**Preferred Query Methods (in order):**

1. **`getByRole`** - Most accessible, user-focused, **REQUIRED for ARIA testing**
2. **`getByLabelText`** - For form elements
3. **`getByPlaceholderText`** - For inputs
4. **`getByText`** - For text content
5. **`getByDisplayValue`** - For form values
6. **`getByTestId`** - Last resort, use with `data-testid`

**ARIA Testing Requirements:**

```typescript
// ✅ REQUIRED: Comprehensive ARIA testing
describe("ARIA Attributes Testing", () => {
  it("applies correct ARIA roles to main layout elements", () => {
    render(<Component internalId="aria-test" />);
    
    const mainElement = screen.getByRole("main");
    expect(mainElement).toHaveAttribute("aria-label", "Component content");
    
    const regionElement = screen.getByRole("region", { name: "Component layout" });
    expect(regionElement).toBeInTheDocument();
  });

  it("applies correct ARIA relationships between elements", () => {
    render(<Component internalId="aria-test" />);
    
    const articleElement = screen.getByRole("article");
    expect(articleElement).toHaveAttribute("aria-labelledby", "aria-test-component-title");
    expect(articleElement).toHaveAttribute("aria-describedby", "aria-test-component-date");
  });
});
```

#### 5. Test Cleanup Requirements

**Mandatory Cleanup Pattern:**

```typescript
import { cleanup, render, screen } from "@testing-library/react";
import { afterEach, describe, expect, it, vi } from "vitest";

describe("ComponentName", () => {
  afterEach(() => {
    cleanup();
    vi.clearAllMocks();
  });
  // Test cases...
});
```

#### 6. Systematic Test Fixing Process

**Step-by-Step Workflow:**

1. **Identify Test Failures**: Run tests to identify specific failure patterns
2. **Fix Mock Structure**: Update `useComponentId` and `createComponentProps` mocks
3. **Remove Classname Expectations**: Replace `toHaveClass` with `toHaveAttribute("class")`
4. **Standardize Data Attributes**: Ensure consistent `data-testid` and debug attributes
5. **Add ARIA Testing**: Implement comprehensive accessibility testing
6. **Verify Test Results**: Run tests to confirm all issues are resolved
7. **Document Changes**: Update component architecture rules with lessons learned

**Common Failure Patterns and Solutions:**

| Failure Pattern | Root Cause | Solution |
|----------------|------------|----------|
| `data-testid="undefined-component"` | `useComponentId` returns wrong structure | Fix mock to return `{ componentId, isDebugMode }` |
| `data-testid="test-id-component-root-root"` | `createComponentProps` adds extra `-root` | Remove `-root` suffix from mock |
| `toHaveClass` failures | Rantail obfuscates classnames | Replace with `toHaveAttribute("class")` |
| Missing ARIA tests | Incomplete accessibility coverage | Add comprehensive ARIA testing suite |

#### 7. Replication Guidelines

**For Future Component Test Fixes:**

1. **Copy Standard Mocks**: Use the standardized mock patterns from this documentation
2. **Apply Rantail Rules**: Remove all classname-specific expectations
3. **Follow Data Attribute Patterns**: Use consistent `data-testid` and debug attributes
4. **Implement ARIA Testing**: Add comprehensive accessibility validation
5. **Use Standard Cleanup**: Include mandatory cleanup in all test files
6. **Test Systematically**: Fix one component at a time, verify results

**Quality Assurance Checklist:**

- [ ] All `useComponentId` mocks return `{ componentId, isDebugMode }`
- [ ] All `createComponentProps` mocks generate correct `data-testid` values
- [ ] No `toHaveClass` expectations remain (replaced with `toHaveAttribute("class")`)
- [ ] All test files include mandatory cleanup
- [ ] ARIA testing is comprehensive and follows accessibility standards
- [ ] Data attributes follow standardized patterns
- [ ] Tests pass consistently across multiple runs

This systematic approach ensures that all component test suites are reliable, maintainable, and compatible with Rantail CSS obfuscation while providing comprehensive coverage of component functionality and accessibility.

## Advanced Component Patterns

### Component Composition Best Practices

#### Higher-Order Components (HOCs)

```typescript
// ✅ GOOD: HOC for common functionality
export function withArticleData<P extends object>(
  Component: React.ComponentType<P & { article: SanityArticle }>
) {
  return function WrappedComponent(props: P & { slug: string }) {
    const { data: article, isLoading, error } = useArticle(props.slug)

    if (isLoading) return <ArticleSkeleton />
    if (error) return <ArticleError error={error} />
    if (!article) return <ArticleNotFound />

    return <Component {...props} article={article} />
  }
}

// Usage
const ArticleWithData = withArticleData(ArticleDisplay)
```

#### Render Props Pattern

```typescript
// ✅ GOOD: Render prop for flexible data handling
export function ArticleDataProvider({
  slug,
  children
}: {
  slug: string
  children: (data: ArticleDataState) => React.ReactNode
}) {
  const { data: article, isLoading, error } = useArticle(slug)

  return children({ article, isLoading, error })
}

// Usage
<ArticleDataProvider slug="my-article">
  {({ article, isLoading, error }) => {
    if (isLoading) return <Skeleton />
    if (error) return <Error />
    return <Article article={article} />
  }}
</ArticleDataProvider>
```

#### Compound Component with Context

```typescript
// ✅ GOOD: Context-based compound component
const CardContext = createContext<CardContextValue | null>(null)

export function Card({ children, ...props }: CardProps) {
  const [state, setState] = useState<CardState>({ isExpanded: false })
  
  return (
    <CardContext.Provider value={{ state, setState }}>
      <div {...props}>{children}</div>
    </CardContext.Provider>
  )
}

function CardTitle({ children }: { children: React.ReactNode }) {
  const context = useContext(CardContext)
  if (!context) throw new Error('CardTitle must be used within Card')
  
  return <h2>{children}</h2>
}

Card.Title = CardTitle
```

### State Management Patterns

#### Custom Hooks for Component State

```typescript
// ✅ GOOD: Custom hook for component state management
export function useArticleState(initialArticle?: SanityArticle) {
  const [article, setArticle] = useState<SanityArticle | null>(
    initialArticle || null
  )
  const [isEditing, setIsEditing] = useState(false)
  const [isPreview, setIsPreview] = useState(false)

  const updateArticle = useCallback((updates: Partial<SanityArticle>) => {
    setArticle((prev) => (prev ? { ...prev, ...updates } : null))
  }, [])

  const resetArticle = useCallback(() => {
    setArticle(initialArticle || null)
    setIsEditing(false)
  }, [initialArticle])

  return {
    article,
    isEditing,
    isPreview,
    setArticle,
    setIsEditing,
    setIsPreview,
    updateArticle,
    resetArticle,
  }
}
```

#### Discriminated Unions for Component States

```typescript
// ✅ GOOD: Discriminated union for component states
export type ArticleState =
  | { status: 'loading' }
  | { status: 'error'; error: Error }
  | { status: 'success'; data: SanityArticle }
  | { status: 'not-found' }

export function ArticleComponent({ slug }: { slug: string }) {
  const [state, setState] = useState<ArticleState>({ status: 'loading' })

  useEffect(() => {
    fetchArticle(slug)
      .then((data) => setState({ status: 'success', data }))
      .catch((error) => setState({ status: 'error', error }))
  }, [slug])

  switch (state.status) {
    case 'loading':
      return <ArticleSkeleton />
    case 'error':
      return <ArticleError error={state.error} />
    case 'success':
      return <Article article={state.data} />
    case 'not-found':
      return <ArticleNotFound />
    default:
      // Exhaustive check
      const _exhaustive: never = state
      return null
  }
}
```

### Error Boundaries

#### Component Error Boundary

```typescript
// ✅ GOOD: Error boundary for component error handling
export class ArticleErrorBoundary extends React.Component<
  { children: React.ReactNode; fallback?: React.ReactNode },
  { hasError: boolean; error: Error | null }
> {
  constructor(props: { children: React.ReactNode; fallback?: React.ReactNode }) {
    super(props)
    this.state = { hasError: false, error: null }
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    logger.error('Article component error:', { error, errorInfo })
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || <ArticleErrorFallback error={this.state.error} />
    }
    return this.props.children
  }
}

// Usage
<ArticleErrorBoundary fallback={<ArticleError />}>
  <Article article={article} />
</ArticleErrorBoundary>
```

### Performance Optimization Patterns

#### Virtual Scrolling for Large Lists

```typescript
// ✅ GOOD: Virtual scrolling for large lists (>100 items)
import { useVirtualizer } from '@tanstack/react-virtual'

export function VirtualizedArticleList({
  articles
}: {
  articles: SanityArticleListItem[]
}) {
  const parentRef = useRef<HTMLDivElement>(null)

  const virtualizer = useVirtualizer({
    count: articles.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 200,
    overscan: 5,
  })

  return (
    <div ref={parentRef} style={{ height: '600px', overflow: 'auto' }}>
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          width: '100%',
          position: 'relative',
        }}
      >
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <div
            key={virtualItem.key}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${virtualItem.size}px`,
              transform: `translateY(${virtualItem.start}px)`,
            }}
          >
            <ArticleListItem article={articles[virtualItem.index]} />
          </div>
        ))}
      </div>
    </div>
  )
}
```

#### Intersection Observer for Lazy Loading

```typescript
// ✅ GOOD: Intersection observer for lazy loading
export function useArticleVisibility(ref: React.RefObject<HTMLElement>) {
  const [isVisible, setIsVisible] = useState(false)

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => setIsVisible(entry.isIntersecting),
      { threshold: 0.1 }
    )

    if (ref.current) observer.observe(ref.current)

    return () => observer.disconnect()
  }, [ref])

  return isVisible
}

// Usage
function Article({ article }: { article: SanityArticle }) {
  const ref = useRef<HTMLElement>(null)
  const isVisible = useArticleVisibility(ref)

  return (
    <article ref={ref}>
      {isVisible ? <ArticleContent article={article} /> : <ArticleSkeleton />}
    </article>
  )
}
```

### Sanity CMS Integration Patterns

#### GROQ Query Organization

```typescript
// ✅ GOOD: GROQ queries in _queries folder
// _queries/Article.queries.ts
export const ARTICLE_QUERY = `*[_type == "article" && slug.current == $slug][0] {
  _id,
  title,
  slug,
  publishedAt,
  content,
  author->{
    name,
    image
  },
  mainImage {
    asset->{
      url,
      metadata
    }
  }
}`

export const ARTICLES_LIST_QUERY = `*[_type == "article"] | order(publishedAt desc) {
  _id,
  title,
  slug,
  publishedAt,
  excerpt,
  mainImage {
    asset->{
      url
    }
  }
}`
```

#### Data Fetching with React Query

```typescript
// ✅ GOOD: React Query for client-side data fetching
import { useQuery } from '@tanstack/react-query'
import { sanityClient } from '@web/lib/sanity'
import { ARTICLE_QUERY } from './_queries/Article.queries'

export function useArticle(slug: string, preview: boolean = false) {
  return useQuery({
    queryKey: ['article', slug, preview],
    queryFn: () => sanityClient.fetch(ARTICLE_QUERY, { slug }),
    staleTime: 5 * 60 * 1000, // 5 minutes
    enabled: !!slug,
  })
}
```

### Advanced TypeScript Patterns

#### Generic Component Props with Constraints

```typescript
// ✅ GOOD: Generic component props with constraints
export interface ArticleComponentProps<T extends SanityArticle = SanityArticle> {
  article: T
  variant?: 'default' | 'compact' | 'featured'
  onAction?: (action: ArticleAction, data: T) => void
}

// Conditional types for dynamic props
export type ArticlePropsWithActions<T extends boolean = false> =
  T extends true
    ? ArticleComponentProps & { actions: ArticleAction[] }
    : ArticleComponentProps
```

#### Utility Types for Component Composition

```typescript
// ✅ GOOD: Utility types for component composition
export type ArticleComponentRef = React.RefObject<HTMLElement>
export type ArticleEventHandler<T = void> = (data: T) => void
export type ArticleAsyncHandler<T = void> = (data: T) => Promise<void>
```

## Industry Standards Compliance

### Component Quality Checklist

- ✅ **Type Safety**: All props properly typed, no `any` types
- ✅ **Accessibility**: WCAG 2.1 AA/AAA compliant, comprehensive ARIA attributes
- ✅ **Performance**: Optimized with memoization, lazy loading, virtual scrolling
- ✅ **Error Handling**: Error boundaries, loading states, error states
- ✅ **Testing**: Comprehensive unit and integration tests
- ✅ **Documentation**: JSDoc comments, Storybook stories, README
- ✅ **Security**: Input validation, XSS prevention, secure defaults
- ✅ **Internationalization**: i18n support with proper file structure
