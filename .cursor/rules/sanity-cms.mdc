---
description: Sanity CMS Integration Standards
globs: ["apps/**/*.tsx", "packages/**/*.tsx"]
alwaysApply: false
---

# Sanity CMS Integration Standards

## Architecture Overview

### Sanity CMS Integration for @web/ Components

For `@web/` components using Sanity CMS:

- **`_queries/Component.queries.ts`**: GROQ queries for Sanity data fetching
- **`_queries/Component.fragments.ts`**: Reusable GROQ fragments
- **`_queries/Component.mutations.ts`**: Sanity mutations (if needed)
- **`_types/Component.types.ts`**: Sanity document types and component interfaces
- **`_data/Component.data.ts`**: Static constants, labels, defaults
- **`_data/Component.i18n.ts`**: Internationalization labels (use dot notation: `Component.i18n.ts`)
- **Never**: GROQ queries in component files - always in `_queries/`

## GROQ Query Patterns

### Basic Query Structure

```typescript
// _queries/Article.queries.ts
export const ARTICLE_QUERY = `*[_type == "article" && slug.current == $slug][0] {
  _id,
  title,
  slug,
  publishedAt,
  content,
  author->{
    name,
    image
  },
  mainImage {
    asset->{
      url,
      metadata
    }
  }
}`;

export const ARTICLES_LIST_QUERY = `*[_type == "article"] | order(publishedAt desc) {
  _id,
  title,
  slug,
  publishedAt,
  excerpt,
  mainImage {
    asset->{
      url
    }
  }
}`;
```

### Query Fragments

```typescript
// _queries/Article.fragments.ts
export const AUTHOR_FRAGMENT = `author->{
  _id,
  name,
  slug,
  image {
    asset->{
      url,
      metadata
    }
  }
}`;

export const IMAGE_FRAGMENT = `{
  asset->{
    _id,
    url,
    metadata {
      dimensions,
      lqip
    }
  },
  alt,
  caption
}`;

export const ARTICLE_FRAGMENT = `{
  _id,
  _type,
  title,
  slug,
  publishedAt,
  excerpt,
  content,
  ${AUTHOR_FRAGMENT},
  mainImage ${IMAGE_FRAGMENT}
}`;
```

### Complex Queries

```typescript
// _queries/Article.queries.ts
export const RELATED_ARTICLES_QUERY = `*[_type == "article" && _id != $currentId] | order(publishedAt desc)[0...3] {
  _id,
  title,
  slug,
  publishedAt,
  mainImage {
    asset->{
      url
    }
  }
}`;

export const ARTICLES_BY_CATEGORY_QUERY = `*[_type == "article" && references($categoryId)] | order(publishedAt desc) {
  _id,
  title,
  slug,
  publishedAt,
  excerpt,
  mainImage {
    asset->{
      url
    }
  }
}`;
```

## Type Generation

### Sanity Document Types

```typescript
// _types/Sanity.types.ts
export interface SanityArticle {
  _id: string;
  _type: "article";
  title: string;
  slug: { current: string };
  publishedAt: string;
  content: any[]; // Portable Text
  author: SanityAuthor;
  mainImage: SanityImage;
  excerpt?: string;
  categories?: SanityCategory[];
}

export interface SanityAuthor {
  _id: string;
  _type: "author";
  name: string;
  slug: { current: string };
  image: SanityImage;
  bio?: string;
}

export interface SanityImage {
  asset: {
    _id: string;
    url: string;
    metadata: {
      dimensions: {
        width: number;
        height: number;
      };
      lqip: string;
    };
  };
  alt?: string;
  caption?: string;
}

export interface SanityCategory {
  _id: string;
  _type: "category";
  title: string;
  slug: { current: string };
  description?: string;
}
```

### Component Interface Types

```typescript
// _types/Article.types.ts
import type { SanityArticle } from './Sanity.types';

/** `ArticleProps` component props. */
export interface ArticleProps extends CommonComponentProps {
  /** Sanity article data */
  article: SanityArticle;
  /** Whether to show full content */
  showFullContent?: boolean;
  /** Whether to enable memoization */
  isMemoized?: boolean;
}

/** `ArticleComponent` component type. */
export type ArticleComponent = React.FC<ArticleProps>;
```

## Data Fetching Patterns

### Server-Side Rendering

```typescript
// Component.tsx
import { sanityClient } from "@web/lib/sanity";
import { ARTICLE_QUERY } from "./_queries/Article.queries";

export async function getArticle(slug: string) {
  return await sanityClient.fetch(ARTICLE_QUERY, { slug });
}

// In Next.js page
export async function getStaticProps({ params }) {
  const article = await getArticle(params.slug);

  return {
    props: { article },
    revalidate: 60, // ISR with 60s revalidation
  };
}
```

### Client-Side Fetching

```typescript
// Custom hook for client-side fetching
import { useQuery } from "@tanstack/react-query";

export function useArticle(slug: string, preview: boolean = false) {
  return useQuery({
    queryKey: ["article", slug, preview],
    queryFn: () => getArticle(slug, preview),
    staleTime: 5 * 60 * 1000, // 5 minutes
    enabled: !!slug,
  });
}

// Usage in component
export function ArticlePage({ slug }: { slug: string }) {
  const { data: article, isLoading, error } = useArticle(slug);

  if (isLoading) return <ArticleSkeleton />;
  if (error) return <ArticleError error={error} />;
  if (!article) return <ArticleNotFound />;

  return <Article article={article} />;
}
```

### Real-Time Updates

```typescript
// Real-time updates with Sanity
import { useDocument } from "@sanity/react-hooks";

export function useArticleRealtime(slug: string) {
  return useDocument({
    query: ARTICLE_QUERY,
    params: { slug },
    options: { enabled: !!slug },
  });
}

// WebSocket connection for live updates
export function useSanityLiveUpdates() {
  useEffect(() => {
    const subscription = sanityClient
      .listen('*[_type == "article"]')
      .subscribe((update) => {
        // Handle real-time updates
        queryClient.invalidateQueries(['articles']);
      });

    return () => subscription.unsubscribe();
  }, []);
}
```

## Image Optimization

### Next.js Image Integration

```typescript
// Optimized Sanity images
import Image from 'next/image';
import { urlFor } from '@web/lib/sanity';

export function SanityImage({ image, alt, ...props }) {
  if (!image?.asset) return null;

  return (
    <Image
      src={urlFor(image).width(800).height(600).quality(80).url()}
      alt={alt || image.alt || ''}
      width={800}
      height={600}
      placeholder="blur"
      blurDataURL={image.asset.metadata.lqip}
      {...props}
    />
  );
}

// Responsive images
export function ResponsiveSanityImage({ image, alt, sizes }) {
  return (
    <Image
      src={urlFor(image).width(1200).quality(80).url()}
      alt={alt || image.alt || ''}
      fill
      sizes={sizes || "(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"}
      placeholder="blur"
      blurDataURL={image.asset.metadata.lqip}
    />
  );
}
```

### Image URL Builder

```typescript
// _queries/Article.queries.ts
export const OPTIMIZED_IMAGE_QUERY = `mainImage {
  asset->{
    _id,
    url,
    metadata {
      dimensions,
      lqip
    }
  },
  alt,
  caption
}`;

// Image URL builder utility
export function buildImageUrl(image: SanityImage, options: {
  width?: number;
  height?: number;
  quality?: number;
  format?: 'webp' | 'jpg' | 'png';
}) {
  const { width, height, quality = 80, format = 'webp' } = options;

  let url = image.asset.url;

  if (width) url += `?w=${width}`;
  if (height) url += `&h=${height}`;
  if (quality) url += `&q=${quality}`;
  if (format) url += `&fm=${format}`;

  return url;
}
```

## Preview Mode

### Draft Content Preview

```typescript
// Preview mode setup
export async function getStaticProps({ params, preview = false }) {
  const article = await sanityClient.fetch(
    ARTICLE_QUERY,
    { slug: params.slug },
    { perspective: preview ? 'previewDrafts' : 'published' }
  );

  return {
    props: { article, preview },
    revalidate: preview ? 0 : 60,
  };
}

// Preview component
export function ArticlePreview({ article, preview }) {
  if (preview) {
    return (
      <div className="preview-banner">
        <p>Preview mode - showing draft content</p>
        <Article article={article} />
      </div>
    );
  }

  return <Article article={article} />;
}
```

### Preview API Routes

```typescript
// pages/api/preview.ts
export default async function preview(req, res) {
  const { slug, secret } = req.query;

  if (secret !== process.env.SANITY_PREVIEW_SECRET) {
    return res.status(401).json({ message: 'Invalid token' });
  }

  const article = await sanityClient.fetch(
    ARTICLE_QUERY,
    { slug },
    { perspective: 'previewDrafts' }
  );

  if (!article) {
    return res.status(404).json({ message: 'Article not found' });
  }

  res.setPreviewData({});
  res.redirect(`/articles/${article.slug.current}`);
}
```

## Error Handling

### Sanity-Specific Error Handling

```typescript
// Error boundary for Sanity components
export class SanityErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // Log to Sanity or error tracking service
    console.error('Sanity component error:', { error, errorInfo });
  }

  render() {
    if (this.state.hasError) {
      return <SanityErrorFallback error={this.state.error} />;
    }
    return this.props.children;
  }
}

// Error fallback component
export function SanityErrorFallback({ error }) {
  return (
    <div className="sanity-error">
      <h2>Content Error</h2>
      <p>There was an error loading the content.</p>
      {process.env.NODE_ENV === 'development' && (
        <details>
          <summary>Error details</summary>
          <pre>{error.message}</pre>
        </details>
      )}
    </div>
  );
}
```

### Data Validation

```typescript
// Validate Sanity data
export function validateArticleData(data: any): data is SanityArticle {
  return (
    data &&
    typeof data._id === 'string' &&
    typeof data.title === 'string' &&
    data.slug?.current &&
    typeof data.publishedAt === 'string'
  );
}

// Safe data access
export function useSafeArticleData(slug: string) {
  const { data, isLoading, error } = useArticle(slug);

  const safeData = useMemo(() => {
    if (!data) return null;

    if (!validateArticleData(data)) {
      throw new Error('Invalid article data structure');
    }

    return data;
  }, [data]);

  return { article: safeData, isLoading, error };
}
```

## Performance Optimization

### Query Optimization

```typescript
// Optimized queries with projections
export const OPTIMIZED_ARTICLES_QUERY = `*[_type == "article"] | order(publishedAt desc)[0...10] {
  _id,
  title,
  slug,
  publishedAt,
  "mainImageUrl": mainImage.asset->url,
  "authorName": author->name
}`;

// Paginated queries
export const PAGINATED_ARTICLES_QUERY = `*[_type == "article"] | order(publishedAt desc)[$start...$end] {
  _id,
  title,
  slug,
  publishedAt,
  mainImage {
    asset->{
      url
    }
  }
}`;
```

### Caching Strategies

```typescript
// React Query with Sanity
export function useArticlesWithCache() {
  return useQuery({
    queryKey: ['articles'],
    queryFn: () => sanityClient.fetch(ARTICLES_QUERY),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
    refetchOnWindowFocus: false,
  });
}

// ISR with Sanity
export async function getStaticProps() {
  const articles = await sanityClient.fetch(ARTICLES_QUERY);

  return {
    props: { articles },
    revalidate: 300, // 5 minutes
  };
}
```

## Environment Configuration

### Sanity Client Setup

```typescript
// lib/sanity.ts
import { createClient } from 'next-sanity';

export const sanityClient = createClient({
  projectId: process.env.NEXT_PUBLIC_SANITY_PROJECT_ID,
  dataset: process.env.NEXT_PUBLIC_SANITY_DATASET,
  apiVersion: '2023-05-03',
  useCdn: process.env.NODE_ENV === 'production',
  token: process.env.SANITY_API_TOKEN,
});

// Preview client
export const previewClient = createClient({
  projectId: process.env.NEXT_PUBLIC_SANITY_PROJECT_ID,
  dataset: process.env.NEXT_PUBLIC_SANITY_DATASET,
  apiVersion: '2023-05-03',
  useCdn: false,
  token: process.env.SANITY_API_TOKEN,
  perspective: 'previewDrafts',
});
```

### Environment Variables

```bash
# .env.local
NEXT_PUBLIC_SANITY_PROJECT_ID=your_project_id
NEXT_PUBLIC_SANITY_DATASET=production
SANITY_API_TOKEN=your_api_token
SANITY_PREVIEW_SECRET=your_preview_secret
```

## Testing Sanity Components

### Mock Sanity Data

```typescript
// Test utilities
export const mockSanityArticle: SanityArticle = {
  _id: 'test-article-id',
  _type: 'article',
  title: 'Test Article',
  slug: { current: 'test-article' },
  publishedAt: '2023-01-01T00:00:00Z',
  content: [],
  author: {
    _id: 'test-author-id',
    _type: 'author',
    name: 'Test Author',
    slug: { current: 'test-author' },
    image: {
      asset: {
        _id: 'test-image-id',
        url: 'https://example.com/image.jpg',
        metadata: {
          dimensions: { width: 800, height: 600 },
          lqip: 'data:image/jpeg;base64,...',
        },
      },
    },
  },
  mainImage: {
    asset: {
      _id: 'test-main-image-id',
      url: 'https://example.com/main-image.jpg',
      metadata: {
        dimensions: { width: 1200, height: 800 },
        lqip: 'data:image/jpeg;base64,...',
      },
    },
  },
};

// Mock Sanity client
vi.mock('@web/lib/sanity', () => ({
  sanityClient: {
    fetch: vi.fn(() => Promise.resolve(mockSanityArticle)),
  },
}));
```

### Component Testing

```typescript
// Test Sanity components
describe('Article with Sanity data', () => {
  it('renders article with Sanity data', () => {
    render(<Article article={mockSanityArticle} />);

    expect(screen.getByText('Test Article')).toBeInTheDocument();
    expect(screen.getByText('Test Author')).toBeInTheDocument();
  });

  it('handles missing Sanity data gracefully', () => {
    const incompleteArticle = { ...mockSanityArticle, title: '' };
    render(<Article article={incompleteArticle} />);

    expect(screen.getByText('Invalid article data')).toBeInTheDocument();
  });
});
```

# Sanity CMS Integration Standards

## Architecture Overview

### Sanity CMS Integration for @web/ Components

For `@web/` components using Sanity CMS:

- **`_queries/Component.queries.ts`**: GROQ queries for Sanity data fetching
- **`_queries/Component.fragments.ts`**: Reusable GROQ fragments
- **`_queries/Component.mutations.ts`**: Sanity mutations (if needed)
- **`_types/Component.types.ts`**: Sanity document types and component interfaces
- **`_data/Component.data.ts`**: Static constants, labels, defaults
- **`_data/Component.i18n.ts`**: Internationalization labels (use dot notation: `Component.i18n.ts`)
- **Never**: GROQ queries in component files - always in `_queries/`

## GROQ Query Patterns

### Basic Query Structure

```typescript
// _queries/Article.queries.ts
export const ARTICLE_QUERY = `*[_type == "article" && slug.current == $slug][0] {
  _id,
  title,
  slug,
  publishedAt,
  content,
  author->{
    name,
    image
  },
  mainImage {
    asset->{
      url,
      metadata
    }
  }
}`;

export const ARTICLES_LIST_QUERY = `*[_type == "article"] | order(publishedAt desc) {
  _id,
  title,
  slug,
  publishedAt,
  excerpt,
  mainImage {
    asset->{
      url
    }
  }
}`;
```

### Query Fragments

```typescript
// _queries/Article.fragments.ts
export const AUTHOR_FRAGMENT = `author->{
  _id,
  name,
  slug,
  image {
    asset->{
      url,
      metadata
    }
  }
}`;

export const IMAGE_FRAGMENT = `{
  asset->{
    _id,
    url,
    metadata {
      dimensions,
      lqip
    }
  },
  alt,
  caption
}`;

export const ARTICLE_FRAGMENT = `{
  _id,
  _type,
  title,
  slug,
  publishedAt,
  excerpt,
  content,
  ${AUTHOR_FRAGMENT},
  mainImage ${IMAGE_FRAGMENT}
}`;
```

### Complex Queries

```typescript
// _queries/Article.queries.ts
export const RELATED_ARTICLES_QUERY = `*[_type == "article" && _id != $currentId] | order(publishedAt desc)[0...3] {
  _id,
  title,
  slug,
  publishedAt,
  mainImage {
    asset->{
      url
    }
  }
}`;

export const ARTICLES_BY_CATEGORY_QUERY = `*[_type == "article" && references($categoryId)] | order(publishedAt desc) {
  _id,
  title,
  slug,
  publishedAt,
  excerpt,
  mainImage {
    asset->{
      url
    }
  }
}`;
```

## Type Generation

### Sanity Document Types

```typescript
// _types/Sanity.types.ts
export interface SanityArticle {
  _id: string;
  _type: "article";
  title: string;
  slug: { current: string };
  publishedAt: string;
  content: any[]; // Portable Text
  author: SanityAuthor;
  mainImage: SanityImage;
  excerpt?: string;
  categories?: SanityCategory[];
}

export interface SanityAuthor {
  _id: string;
  _type: "author";
  name: string;
  slug: { current: string };
  image: SanityImage;
  bio?: string;
}

export interface SanityImage {
  asset: {
    _id: string;
    url: string;
    metadata: {
      dimensions: {
        width: number;
        height: number;
      };
      lqip: string;
    };
  };
  alt?: string;
  caption?: string;
}

export interface SanityCategory {
  _id: string;
  _type: "category";
  title: string;
  slug: { current: string };
  description?: string;
}
```

### Component Interface Types

```typescript
// _types/Article.types.ts
import type { SanityArticle } from './Sanity.types';

/** `ArticleProps` component props. */
export interface ArticleProps extends CommonComponentProps {
  /** Sanity article data */
  article: SanityArticle;
  /** Whether to show full content */
  showFullContent?: boolean;
  /** Whether to enable memoization */
  isMemoized?: boolean;
}

/** `ArticleComponent` component type. */
export type ArticleComponent = React.FC<ArticleProps>;
```

## Data Fetching Patterns

### Server-Side Rendering

```typescript
// Component.tsx
import { sanityClient } from "@web/lib/sanity";
import { ARTICLE_QUERY } from "./_queries/Article.queries";

export async function getArticle(slug: string) {
  return await sanityClient.fetch(ARTICLE_QUERY, { slug });
}

// In Next.js page
export async function getStaticProps({ params }) {
  const article = await getArticle(params.slug);

  return {
    props: { article },
    revalidate: 60, // ISR with 60s revalidation
  };
}
```

### Client-Side Fetching

```typescript
// Custom hook for client-side fetching
import { useQuery } from "@tanstack/react-query";

export function useArticle(slug: string, preview: boolean = false) {
  return useQuery({
    queryKey: ["article", slug, preview],
    queryFn: () => getArticle(slug, preview),
    staleTime: 5 * 60 * 1000, // 5 minutes
    enabled: !!slug,
  });
}

// Usage in component
export function ArticlePage({ slug }: { slug: string }) {
  const { data: article, isLoading, error } = useArticle(slug);

  if (isLoading) return <ArticleSkeleton />;
  if (error) return <ArticleError error={error} />;
  if (!article) return <ArticleNotFound />;

  return <Article article={article} />;
}
```

### Real-Time Updates

```typescript
// Real-time updates with Sanity
import { useDocument } from "@sanity/react-hooks";

export function useArticleRealtime(slug: string) {
  return useDocument({
    query: ARTICLE_QUERY,
    params: { slug },
    options: { enabled: !!slug },
  });
}

// WebSocket connection for live updates
export function useSanityLiveUpdates() {
  useEffect(() => {
    const subscription = sanityClient
      .listen('*[_type == "article"]')
      .subscribe((update) => {
        // Handle real-time updates
        queryClient.invalidateQueries(['articles']);
      });

    return () => subscription.unsubscribe();
  }, []);
}
```

## Image Optimization

### Next.js Image Integration

```typescript
// Optimized Sanity images
import Image from 'next/image';
import { urlFor } from '@web/lib/sanity';

export function SanityImage({ image, alt, ...props }) {
  if (!image?.asset) return null;

  return (
    <Image
      src={urlFor(image).width(800).height(600).quality(80).url()}
      alt={alt || image.alt || ''}
      width={800}
      height={600}
      placeholder="blur"
      blurDataURL={image.asset.metadata.lqip}
      {...props}
    />
  );
}

// Responsive images
export function ResponsiveSanityImage({ image, alt, sizes }) {
  return (
    <Image
      src={urlFor(image).width(1200).quality(80).url()}
      alt={alt || image.alt || ''}
      fill
      sizes={sizes || "(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"}
      placeholder="blur"
      blurDataURL={image.asset.metadata.lqip}
    />
  );
}
```

### Image URL Builder

```typescript
// _queries/Article.queries.ts
export const OPTIMIZED_IMAGE_QUERY = `mainImage {
  asset->{
    _id,
    url,
    metadata {
      dimensions,
      lqip
    }
  },
  alt,
  caption
}`;

// Image URL builder utility
export function buildImageUrl(image: SanityImage, options: {
  width?: number;
  height?: number;
  quality?: number;
  format?: 'webp' | 'jpg' | 'png';
}) {
  const { width, height, quality = 80, format = 'webp' } = options;

  let url = image.asset.url;

  if (width) url += `?w=${width}`;
  if (height) url += `&h=${height}`;
  if (quality) url += `&q=${quality}`;
  if (format) url += `&fm=${format}`;

  return url;
}
```

## Preview Mode

### Draft Content Preview

```typescript
// Preview mode setup
export async function getStaticProps({ params, preview = false }) {
  const article = await sanityClient.fetch(
    ARTICLE_QUERY,
    { slug: params.slug },
    { perspective: preview ? 'previewDrafts' : 'published' }
  );

  return {
    props: { article, preview },
    revalidate: preview ? 0 : 60,
  };
}

// Preview component
export function ArticlePreview({ article, preview }) {
  if (preview) {
    return (
      <div className="preview-banner">
        <p>Preview mode - showing draft content</p>
        <Article article={article} />
      </div>
    );
  }

  return <Article article={article} />;
}
```

### Preview API Routes

```typescript
// pages/api/preview.ts
export default async function preview(req, res) {
  const { slug, secret } = req.query;

  if (secret !== process.env.SANITY_PREVIEW_SECRET) {
    return res.status(401).json({ message: 'Invalid token' });
  }

  const article = await sanityClient.fetch(
    ARTICLE_QUERY,
    { slug },
    { perspective: 'previewDrafts' }
  );

  if (!article) {
    return res.status(404).json({ message: 'Article not found' });
  }

  res.setPreviewData({});
  res.redirect(`/articles/${article.slug.current}`);
}
```

## Error Handling

### Sanity-Specific Error Handling

```typescript
// Error boundary for Sanity components
export class SanityErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // Log to Sanity or error tracking service
    console.error('Sanity component error:', { error, errorInfo });
  }

  render() {
    if (this.state.hasError) {
      return <SanityErrorFallback error={this.state.error} />;
    }
    return this.props.children;
  }
}

// Error fallback component
export function SanityErrorFallback({ error }) {
  return (
    <div className="sanity-error">
      <h2>Content Error</h2>
      <p>There was an error loading the content.</p>
      {process.env.NODE_ENV === 'development' && (
        <details>
          <summary>Error details</summary>
          <pre>{error.message}</pre>
        </details>
      )}
    </div>
  );
}
```

### Data Validation

```typescript
// Validate Sanity data
export function validateArticleData(data: any): data is SanityArticle {
  return (
    data &&
    typeof data._id === 'string' &&
    typeof data.title === 'string' &&
    data.slug?.current &&
    typeof data.publishedAt === 'string'
  );
}

// Safe data access
export function useSafeArticleData(slug: string) {
  const { data, isLoading, error } = useArticle(slug);

  const safeData = useMemo(() => {
    if (!data) return null;

    if (!validateArticleData(data)) {
      throw new Error('Invalid article data structure');
    }

    return data;
  }, [data]);

  return { article: safeData, isLoading, error };
}
```

## Performance Optimization

### Query Optimization

```typescript
// Optimized queries with projections
export const OPTIMIZED_ARTICLES_QUERY = `*[_type == "article"] | order(publishedAt desc)[0...10] {
  _id,
  title,
  slug,
  publishedAt,
  "mainImageUrl": mainImage.asset->url,
  "authorName": author->name
}`;

// Paginated queries
export const PAGINATED_ARTICLES_QUERY = `*[_type == "article"] | order(publishedAt desc)[$start...$end] {
  _id,
  title,
  slug,
  publishedAt,
  mainImage {
    asset->{
      url
    }
  }
}`;
```

### Caching Strategies

```typescript
// React Query with Sanity
export function useArticlesWithCache() {
  return useQuery({
    queryKey: ['articles'],
    queryFn: () => sanityClient.fetch(ARTICLES_QUERY),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
    refetchOnWindowFocus: false,
  });
}

// ISR with Sanity
export async function getStaticProps() {
  const articles = await sanityClient.fetch(ARTICLES_QUERY);

  return {
    props: { articles },
    revalidate: 300, // 5 minutes
  };
}
```

## Environment Configuration

### Sanity Client Setup

```typescript
// lib/sanity.ts
import { createClient } from 'next-sanity';

export const sanityClient = createClient({
  projectId: process.env.NEXT_PUBLIC_SANITY_PROJECT_ID,
  dataset: process.env.NEXT_PUBLIC_SANITY_DATASET,
  apiVersion: '2023-05-03',
  useCdn: process.env.NODE_ENV === 'production',
  token: process.env.SANITY_API_TOKEN,
});

// Preview client
export const previewClient = createClient({
  projectId: process.env.NEXT_PUBLIC_SANITY_PROJECT_ID,
  dataset: process.env.NEXT_PUBLIC_SANITY_DATASET,
  apiVersion: '2023-05-03',
  useCdn: false,
  token: process.env.SANITY_API_TOKEN,
  perspective: 'previewDrafts',
});
```

### Environment Variables

```bash
# .env.local
NEXT_PUBLIC_SANITY_PROJECT_ID=your_project_id
NEXT_PUBLIC_SANITY_DATASET=production
SANITY_API_TOKEN=your_api_token
SANITY_PREVIEW_SECRET=your_preview_secret
```

## Testing Sanity Components

### Mock Sanity Data

```typescript
// Test utilities
export const mockSanityArticle: SanityArticle = {
  _id: 'test-article-id',
  _type: 'article',
  title: 'Test Article',
  slug: { current: 'test-article' },
  publishedAt: '2023-01-01T00:00:00Z',
  content: [],
  author: {
    _id: 'test-author-id',
    _type: 'author',
    name: 'Test Author',
    slug: { current: 'test-author' },
    image: {
      asset: {
        _id: 'test-image-id',
        url: 'https://example.com/image.jpg',
        metadata: {
          dimensions: { width: 800, height: 600 },
          lqip: 'data:image/jpeg;base64,...',
        },
      },
    },
  },
  mainImage: {
    asset: {
      _id: 'test-main-image-id',
      url: 'https://example.com/main-image.jpg',
      metadata: {
        dimensions: { width: 1200, height: 800 },
        lqip: 'data:image/jpeg;base64,...',
      },
    },
  },
};

// Mock Sanity client
vi.mock('@web/lib/sanity', () => ({
  sanityClient: {
    fetch: vi.fn(() => Promise.resolve(mockSanityArticle)),
  },
}));
```

### Component Testing

```typescript
// Test Sanity components
describe('Article with Sanity data', () => {
  it('renders article with Sanity data', () => {
    render(<Article article={mockSanityArticle} />);

    expect(screen.getByText('Test Article')).toBeInTheDocument();
    expect(screen.getByText('Test Author')).toBeInTheDocument();
  });

  it('handles missing Sanity data gracefully', () => {
    const incompleteArticle = { ...mockSanityArticle, title: '' };
    render(<Article article={incompleteArticle} />);

    expect(screen.getByText('Invalid article data')).toBeInTheDocument();
  });
});
```
