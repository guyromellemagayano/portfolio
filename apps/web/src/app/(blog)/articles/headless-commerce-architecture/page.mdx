import { ArticleLayout } from '@web/components/layout'

export const article = {
  author: 'Guy Romelle Magayano',
  date: '2024-11-20',
  title: 'Headless Commerce Architecture: Commercetools + Next.js Best Practices',
  description:
    'Building headless commerce platforms requires careful consideration of API integration, state management, and performance. Here are the patterns and practices that worked for production e-commerce sites.',
}

export const metadata = {
  title: article.title,
  description: article.description,
}

export default (props) => <ArticleLayout article={article} {...props} />

Headless commerce has become the standard for modern e-commerce platforms. By decoupling the frontend from the commerce backend, you gain flexibility, performance, and the ability to deliver consistent experiences across channels. But building a production-ready headless commerce platform comes with its own set of challenges.

During my work on projects like Marimekko and IONA Commerce, I've learned what works—and what doesn't—when integrating Commercetools with Next.js.

## Why Headless Commerce?

Traditional monolithic e-commerce platforms tie you to their frontend. Headless commerce separates concerns:

- **Frontend**: Next.js for fast, SEO-friendly storefronts
- **Commerce Backend**: Commercetools for catalog, cart, checkout, and orders
- **CMS**: Sanity for content management
- **Deployment**: Vercel for edge-optimized delivery

This separation allows you to optimize each layer independently.

## Architecture Patterns

### API Integration Layer

The key to a maintainable headless commerce platform is a well-designed API integration layer. I created a service layer that abstracts Commercetools complexity:

```typescript
// services/commercetools.ts
export class CommerceService {
  private client: Client
  
  async getProduct(productKey: string) {
    const response = await this.client.execute({
      uri: `/products/key=${productKey}`,
      method: 'GET',
    })
    return this.transformProduct(response.body)
  }
  
  async addToCart(cartId: string, lineItem: LineItem) {
    // Handle errors, retries, and validation
    return this.client.execute({
      uri: `/carts/${cartId}`,
      method: 'POST',
      body: {
        version: cart.version,
        actions: [{
          action: 'addLineItem',
          ...lineItem,
        }],
      },
    })
  }
}
```

### State Management with Jotai

For complex commerce flows, I used Jotai for state management. It's lightweight and works well with server components:

```typescript
// atoms/cart.ts
export const cartAtom = atom<Cart | null>(null)

export const cartItemsAtom = atom(
  (get) => get(cartAtom)?.lineItems ?? []
)

// In components
function CartButton() {
  const [cart, setCart] = useAtom(cartAtom)
  // ...
}
```

### Form Validation with Zod

Commerce forms need robust validation. Zod provides type-safe validation that works on both client and server:

```typescript
const checkoutSchema = z.object({
  email: z.string().email(),
  shippingAddress: z.object({
    streetName: z.string().min(1),
    city: z.string().min(1),
    country: z.string().length(2),
  }),
  paymentMethod: z.enum(['credit_card', 'paypal']),
})

// Validate on client before submission
const result = checkoutSchema.safeParse(formData)
if (!result.success) {
  // Show validation errors
}
```

## Performance Optimization

### Incremental Static Regeneration (ISR)

Product pages benefit from ISR. They're statically generated but can be updated when products change:

```typescript
export async function generateStaticParams() {
  const products = await commerceService.getAllProducts()
  return products.map((product) => ({
    slug: product.slug,
  }))
}

export const revalidate = 3600 // Revalidate every hour
```

### Image Optimization

E-commerce sites have many images. Next.js Image component with AVIF/WebP formats significantly improves performance:

```typescript
<Image
  src={product.imageUrl}
  alt={product.name}
  width={800}
  height={800}
  format="avif"
  priority={isAboveFold}
/>
```

### API Query Optimization

Commercetools queries can be slow if not optimized. Key practices:

1. **Projection**: Only fetch fields you need
2. **Filtering**: Filter on the server, not in JavaScript
3. **Caching**: Cache product data with appropriate TTLs
4. **Batching**: Batch related queries when possible

```typescript
// Good: Projection and filtering
const products = await client.execute({
  uri: '/product-projections/search',
  method: 'GET',
  queryParams: {
    limit: 20,
    where: 'categories.id:"category-id"',
    // Only fetch needed fields
    staged: false,
  },
})
```

## Checkout Reliability

Checkout is the money-making path. It needs to be bulletproof:

### Error Handling

```typescript
async function processCheckout(cart: Cart) {
  try {
    // Validate cart state
    if (!cart.lineItems.length) {
      throw new Error('Cart is empty')
    }
    
    // Create order with retry logic
    const order = await retryWithBackoff(
      () => commerceService.createOrder(cart),
      { maxRetries: 3 }
    )
    
    return order
  } catch (error) {
    // Log error for monitoring
    // Return user-friendly error message
    throw new CheckoutError('Failed to process order')
  }
}
```

### Promotion Logic

Promotions and vouchers need careful validation:

```typescript
async function applyPromotionCode(cartId: string, code: string) {
  // Validate code format
  if (!isValidPromoCode(code)) {
    return { error: 'Invalid promotion code' }
  }
  
  // Check eligibility
  const cart = await getCart(cartId)
  if (!isEligibleForPromotion(cart, code)) {
    return { error: 'Promotion not applicable' }
  }
  
  // Apply with version check
  return await commerceService.addDiscountCode(cartId, code)
}
```

## Testing Strategy

E-commerce platforms need comprehensive testing:

### Unit Tests

Test business logic in isolation:

```typescript
describe('CartService', () => {
  it('calculates total correctly with promotions', () => {
    const cart = createTestCart()
    const total = calculateTotal(cart)
    expect(total).toBe(99.99)
  })
})
```

### Integration Tests

Test API integration:

```typescript
describe('Commerce Integration', () => {
  it('creates order successfully', async () => {
    const order = await commerceService.createOrder(testCart)
    expect(order.id).toBeDefined()
  })
})
```

### End-to-End Tests

Test critical user flows:

```typescript
describe('Checkout Flow', () => {
  it('completes purchase successfully', () => {
    cy.visit('/products/product-1')
    cy.get('[data-testid="add-to-cart"]').click()
    cy.visit('/checkout')
    cy.fillCheckoutForm()
    cy.get('[data-testid="place-order"]').click()
    cy.url().should('include', '/order-confirmation')
  })
})
```

## Lessons Learned

### 1. Version Management is Critical

Commercetools uses optimistic locking with version numbers. Always handle version conflicts gracefully:

```typescript
async function updateCart(cartId: string, actions: Action[]) {
  const cart = await getCart(cartId)
  try {
    return await commerceService.updateCart(cartId, cart.version, actions)
  } catch (error) {
    if (error.code === 'ConcurrentModification') {
      // Retry with fresh cart
      return updateCart(cartId, actions)
    }
    throw error
  }
}
```

### 2. Cache Strategically

Cache product data aggressively, but invalidate on updates. Cart data should be fresh.

### 3. Monitor Everything

Track API response times, error rates, and checkout abandonment. These metrics guide optimization efforts.

### 4. Test Promotion Logic Thoroughly

Promotions are complex. Test edge cases: overlapping promotions, minimum order values, product exclusions.

## The Result

By following these patterns, we built headless commerce platforms that:

- Meet Core Web Vitals thresholds
- Handle high traffic during sales events
- Provide reliable checkout experiences
- Scale horizontally as needed

Headless commerce isn't just a trend—it's the future of e-commerce. With the right architecture and practices, you can build platforms that are fast, reliable, and maintainable.
