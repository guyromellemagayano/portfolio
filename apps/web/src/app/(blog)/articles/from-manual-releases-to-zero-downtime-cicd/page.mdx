import { ArticleLayout } from '@web/components/layout'

export const article = {
  author: 'Guy Romelle Magayano',
  date: '2024-10-10',
  title: 'From Manual Releases to Zero-Downtime CI/CD: A Journey',
  description:
    'Leading teams from manual, error-prone deployments to fully automated CI/CD pipelines taught me that automation isn\'t just about speed—it\'s about reliability, confidence, and enabling teams to move fast safely.',
}

export const metadata = {
  title: article.title,
  description: article.description,
}

export default (props) => <ArticleLayout article={article} {...props} />

When I joined my first team as a senior engineer, deployments were a manual, nerve-wracking process. We'd coordinate via Slack, run scripts manually, and hope nothing broke. Downtime was common, rollbacks were painful, and the team dreaded release days.

Over the years, I've led multiple teams through the journey from manual releases to fully automated, zero-downtime CI/CD pipelines. Here's what I learned.

## The Starting Point: Manual Deployments

The typical manual deployment process looked like this:

1. Developer: "Ready to deploy?"
2. Team Lead: "Everyone stop working, we're deploying"
3. Developer runs deployment scripts manually
4. Team watches logs nervously
5. Something breaks
6. Panic, rollback, try again tomorrow

This process was:
- **Error-prone**: Manual steps meant human error
- **Slow**: Coordinating the team took time
- **Risky**: No easy way to rollback
- **Stressful**: Everyone dreaded release days

## Phase 1: Basic Automation

The first step was automating the deployment script itself. We moved from manual commands to a single script:

```bash
#!/bin/bash
# deploy.sh

set -e  # Exit on error

echo "Building..."
npm run build

echo "Running tests..."
npm test

echo "Deploying..."
./deploy-to-server.sh

echo "Deployment complete!"
```

This simple change eliminated typos and ensured we always ran tests before deploying.

## Phase 2: CI Pipeline

Next, we set up a CI pipeline with GitHub Actions. Every pull request now:

1. Runs linting
2. Runs type checking
3. Runs tests
4. Builds the application
5. Creates a preview deployment

```yaml
# .github/workflows/ci.yml
name: CI

on:
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm run lint
      - run: npm run type-check
      - run: npm test
      - run: npm run build
```

This caught issues before they reached production.

## Phase 3: Automated Deployments

With CI in place, we automated deployments. Merges to main automatically deployed to production:

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: npm ci
      - run: npm test
      - run: npm run build
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.ORG_ID }}
          vercel-project-id: ${{ secrets.PROJECT_ID }}
```

## Phase 4: Infrastructure as Code

Manual infrastructure changes were the next pain point. We moved to Terraform:

```hcl
# infrastructure/main.tf
resource "aws_ecs_cluster" "app" {
  name = "app-cluster"
}

resource "aws_ecs_service" "app" {
  name            = "app-service"
  cluster         = aws_ecs_cluster.app.id
  task_definition = aws_ecs_task_definition.app.arn
  desired_count   = 2
  
  deployment_configuration {
    maximum_percent         = 200
    minimum_healthy_percent = 100
  }
}
```

Now infrastructure changes were:
- Version controlled
- Reviewable via pull requests
- Reversible
- Documented

## Phase 5: Zero-Downtime Deployments

The final step was achieving zero-downtime deployments. For our Next.js apps on Vercel, this came built-in. For our Django/Go services on AWS ECS, we implemented blue-green deployments:

```yaml
# .github/workflows/deploy-ecs.yml
- name: Deploy to ECS
  run: |
    # Create new task definition
    aws ecs register-task-definition \
      --cli-input-json file://task-definition.json
    
    # Update service with new task definition
    aws ecs update-service \
      --cluster app-cluster \
      --service app-service \
      --task-definition app:latest \
      --force-new-deployment
    
    # Wait for deployment to complete
    aws ecs wait services-stable \
      --cluster app-cluster \
      --services app-service
```

ECS handles the rollout:
1. Starts new tasks with new code
2. Waits for health checks to pass
3. Gradually shifts traffic to new tasks
4. Stops old tasks
5. All without downtime

## PR Gates and Quality Checks

Automation enabled us to add quality gates:

```yaml
jobs:
  quality-gates:
    runs-on: ubuntu-latest
    steps:
      - name: Type Check
        run: npm run type-check
      
      - name: Lint
        run: npm run lint
      
      - name: Tests
        run: npm test -- --coverage
      
      - name: Build
        run: npm run build
      
      - name: Check Coverage
        run: |
          coverage=$(npm test -- --coverage --coverageReporters=text-summary | grep -oP 'All files[^|]*\|\s+\K[0-9.]+')
          if (( $(echo "$coverage < 80" | bc -l) )); then
            echo "Coverage below 80%"
            exit 1
          fi
```

PRs can't merge unless:
- All tests pass
- Type checking passes
- Linting passes
- Coverage meets threshold
- Build succeeds

## Branch Protection Rules

We enforced these gates with GitHub branch protection:

- Require pull request reviews
- Require status checks to pass
- Require branches to be up to date
- Prevent force pushes
- Prevent deletion of protected branches

## Monitoring and Observability

Automation also enabled better monitoring. We added:

- **Deployment tracking**: Know what's deployed when
- **Error tracking**: Sentry for production errors
- **Performance monitoring**: Track Core Web Vitals
- **Uptime monitoring**: Know immediately if something breaks

## The Impact

The transformation from manual to automated deployments had profound effects:

### Developer Experience

- **Confidence**: Developers deploy with confidence, knowing tests and checks have passed
- **Speed**: Deployments happen in minutes, not hours
- **Frequency**: We deploy multiple times per day instead of weekly
- **Less Stress**: No more "deployment day" anxiety

### Business Impact

- **Faster Time to Market**: Features reach users faster
- **Fewer Bugs**: Automated testing catches issues early
- **Less Downtime**: Zero-downtime deployments mean no service interruption
- **Better Quality**: Quality gates ensure only good code reaches production

### Team Culture

- **Trust**: Automation builds trust in the deployment process
- **Experimentation**: Safe deployments enable experimentation
- **Learning**: Failed deployments become learning opportunities, not disasters

## Lessons Learned

### 1. Start Small

You don't need to automate everything at once. Start with the most painful part and iterate.

### 2. Automate Testing First

Good automation requires good tests. Invest in testing infrastructure early.

### 3. Make It Reversible

Every deployment should be easily reversible. This gives confidence to deploy frequently.

### 4. Monitor Everything

Automation without monitoring is dangerous. You need to know when things go wrong.

### 5. Document the Process

As you automate, document why decisions were made. Future you will thank present you.

## The Journey Continues

CI/CD isn't a destination—it's a journey. We're always improving:

- Adding more automated tests
- Improving deployment speed
- Enhancing monitoring
- Refining quality gates

But the foundation is solid. We can deploy with confidence, move fast safely, and focus on building features instead of managing deployments.

The journey from manual releases to zero-downtime CI/CD transformed not just our deployment process, but our entire engineering culture. Automation enabled us to move faster, with more confidence, and less stress.
